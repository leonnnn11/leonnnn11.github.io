# 2026年2月6日  
一周左右过去了，上次说上一篇写完第二天就接着更新，但是显然我没有更新，因为赶着补集训时候的题目  
目前自己训练了一段时间了，总共A了，dp题（集训第一天）8道，数学题（集训第二天）4道，线段树题（集训第三天）1道，高等dp题（集训第四天）3道，最终测试（集训第七天）2道  
总共19道，除了cooking这道题是atcoder的在洛谷上没有提交记录，其他均在洛谷上过了，总共是1道橙题，2道黄题，10道绿题，5道蓝题  
可以看到进步是飞跃式的，那么废话也不多说，继续总结来！写博客也是我复习的一部分，每次写博客都是重新把题目吃透一次  

下面来看第一题！货币系统  
难度：绿题  
# P5020 [NOIP 2018 提高组] 货币系统

## 题目背景

NOIP2018 提高组 D1T2

## 题目描述

在网友的国度中共有 $n$ 种不同面额的货币，第 $i$ 种货币的面额为 $a[i]$，你可以假设每一种货币都有无穷多张。为了方便，我们把货币种数为 $n$、面额数组为 $a[1..n]$ 的货币系统记作 $(n,a)$。 

在一个完善的货币系统中，每一个非负整数的金额 $x$ 都应该可以被表示出，即对每一个非负整数 $x$，都存在 $n$ 个非负整数 $t[i]$ 满足 $a[i] \times t[i]$ 的和为 $x$。然而， 在网友的国度中，货币系统可能是不完善的，即可能存在金额 $x$ 不能被该货币系统表示出。例如在货币系统 $n=3$, $a=[2,5,9]$ 中，金额 $1,3$ 就无法被表示出来。 

两个货币系统 $(n,a)$ 和 $(m,b)$ 是等价的，当且仅当对于任意非负整数 $x$，它要么均可以被两个货币系统表出，要么不能被其中任何一个表出。 

现在网友们打算简化一下货币系统。他们希望找到一个货币系统 $(m,b)$，满足 $(m,b)$ 与原来的货币系统 $(n,a)$ 等价，且 $m$ 尽可能的小。他们希望你来协助完成这个艰巨的任务：找到最小的 $m$。

## 输入格式

输入文件的第一行包含一个整数 $T$，表示数据的组数。

接下来按照如下格式分别给出 $T$ 组数据。 每组数据的第一行包含一个正整数 $n$。接下来一行包含 $n$ 个由空格隔开的正整数 $a[i]$。

## 输出格式

输出文件共有 $T$ 行，对于每组数据，输出一行一个正整数，表示所有与 $(n,a)$ 等价的货币系统 $(m,b)$ 中，最小的 $m$。

## 输入输出样例 #1

### 输入 #1

```
2
4
3 19 10 6
5
11 29 13 19 17
```

### 输出 #1

```
2
5
```

## 说明/提示

在第一组数据中，货币系统 $(2, [3,10])$ 和给出的货币系统 $(n, a)$ 等价，并可以验证不存在 $m < 2$ 的等价的货币系统，因此答案为 $2$。 在第二组数据中，可以验证不存在 $m < n$ 的等价的货币系统，因此答案为 $5$。 

【数据范围与约定】

![](https://cdn.luogu.com.cn/upload/pic/43160.png)  

对于 $100\%$ 的数据，满足 $1 ≤ T ≤ 20, n,a[i] ≥ 1$。  

大致来看这一道题目，首先可以想到的是新加入一种类型的货币时，我们能不能用比其面值小的货币（已经在系统里面了）来表示出这种货币，所以我们可以先排序，然后，这可以用完全背包dp实现，因为每种货币可以选很多次，然后我们加入下一种货币前需要更新能表式出来的  
这时候我们既然加进来了，那就顺带用背包dp把从这个值开始到最大货币值每个都dp出来，1表示可以表示出来，0表示表示不出来，用judge数组表示，状态转移方程judge[k]=judge[k]||judge[k-arr[j]];符合完全背包中“先拿一个”剩下看已知的状态。  
下面是解题代码（本人这里还不是很会dp，是看了答案才会的）  
```cpp
#include<iostream>
using namespace std;
#include<vector>
#include<algorithm>
int main()
{
	int n,m,num;
	cin>>n;
	for(int r=0;r<n;r++)
	{
		vector<int> arr;
		vector<int> same;
		cin>>m;
		for(int i=0;i<m;i++)
		{
			cin>>num;
			arr.push_back(num);
		}
		sort(arr.begin(),arr.end());
		int maxx=arr[m-1];
		vector<int> judge(maxx+1,0);//此处写成maxx，数组开小了，AI纠正后才正确
		judge[0]=1;
		for(unsigned int j=0;j<arr.size();j++)
		{
			if(judge[arr[j]]==0)
			{
				same.push_back(arr[j]);
				for(int k=arr[j];k<=maxx;k++)
				{
					judge[k]=judge[k]||judge[k-arr[j]];
				}
			}
		}
		cout<<same.size()<<endl;
	}
	return 0;
}
```
中间数组开小了WA了一次，其他没有什么大问题。  

接下来来看下一题cooking（出自atcoder）  
难度：黄题（其实不止这难度）  
# AT_abc204_d [ABC204D] Cooking

## 题目描述

高桥君打算制作从 $1$ 到 $N$ 的 $N$ 道菜。

第 $i$ 道菜需要连续使用烤箱 $T_i$ 分钟来完成。一个烤箱在同一时刻不能同时用于两道或以上的菜。

如果可以使用两个烤箱，制作完所有 $N$ 道菜所需的最短时间是多少？此外，除了使用烤箱的时间外，其他时间可以忽略不计。

## 输入格式

输入以以下格式从标准输入中给出。

> $N$ $T_1$ $T_2$ $\ldots$ $T_N$

## 输出格式

请输出答案。

## 输入输出样例 #1

### 输入 #1

```
5
8 3 7 2 5
```

### 输出 #1

```
13
```

## 输入输出样例 #2

### 输入 #2

```
2
1000 1
```

### 输出 #2

```
1000
```

## 输入输出样例 #3

### 输入 #3

```
9
3 14 15 9 26 5 35 89 79
```

### 输出 #3

```
138
```

## 说明/提示

## 限制条件

- $1 \leq N \leq 100$
- $1 \leq T_i \leq 10^3$
- 输入中的所有值均为整数

## 样例解释 1

例如，可以如下使用两个烤箱，在 $13$ 分钟内完成所有菜品。
- 第一个烤箱：依次制作菜 $5, 1$。
- 第二个烤箱：依次制作菜 $2, 4, 3$。

由 ChatGPT 4.1 翻译  
这是洛谷的翻译版，这里同时附上原版  
Time Limit: 2 sec / Memory Limit: 1024 MiB

Score : 
400 points

Problem Statement
Takahashi is going to cook 
N dishes called Dish 
1 through 
N.

Dish 
i can be cooked by using an oven for 
T 
i
​
  consecutive minutes. An oven cannot be used for two or more dishes simultaneously.

If Takahashi has two ovens to use, what is the shortest number of minutes needed to cook all the 
N dishes? Assume that all processes other than using ovens take negligible time.

Constraints
1≤N≤100
1≤T 
i
​
 ≤10 
3
 
All values in input are integers.
Input
Input is given from Standard Input in the following format:

N
T 
1
​
  
… 
T 
N
​
 
Output
Print the answer.

Sample Input 1
Copy
5
8 3 7 2 5
Sample Output 1
Copy
13
We can, for example, use the two ovens as follows to cook all the dishes in 
13 minutes.

The first oven: Cook Dishes 
5 and 
1 in this order.
The second oven: Cook Dishes 
2, 
4, and 
3 in this order.
Sample Input 2
Copy
2
1000 1
Sample Output 2
Copy
1000
Sample Input 3
Copy
9
3 14 15 9 26 5 35 89 79   
Sample Output 3
Copy
138  
我们来看这道题，两个烤箱，烤很多东西，最快的情况当然是能两个烤箱时间一样，第二好的情况是一个多一单位时间，另一个少一单位时间，那么问题变成了我们依次从最好的情况（总时间除以2）向下枚举到最差情况，看看我们能凑出的最接近总时间除以2的值  
那么这题就变成和上一题一样了！！不过每个食物只能烤一次，所以是01背包而不是完全背包，状态转移方程：
```cpp
for(int j=judge.size()-1;j>=arr[i];j--)
{
	judge[j]=judge[j]||judge[j-arr[i]];
}
```
此处转移的时候记得从上至下，因为数组是一维的，显然没必要开二维，因为我们连滚动数组都不需要，因为是01背包所以要从上至下，因为状态转移时要从下面的转移过来，要保证下面的没有被更新过  
那么这道题就很清晰啦  
接着来看再下一题，没有上司的舞会。  
不同于上面的线性dp用数组储存状态，这道题是树形dp，需要用树上节点来储存状态  
题目如下  
# P1352 没有上司的舞会

## 题目描述

某大学有 $n$ 个职员，编号为 $1\ldots n$。

他们之间有从属关系，也就是说他们的关系就像一棵以校长为根的树，父结点就是子结点的直接上司。

现在有个周年庆宴会，宴会每邀请来一个职员都会增加一定的快乐指数 $r_i$，但是呢，如果某个职员的直接上司来参加舞会了，那么这个职员就无论如何也不肯来参加舞会了。

所以，请你编程计算，邀请哪些职员可以使快乐指数最大，求最大的快乐指数。

## 输入格式

输入的第一行是一个整数 $n$。

第 $2$ 到第 $(n + 1)$ 行，每行一个整数，第 $(i+1)$ 行的整数表示 $i$ 号职员的快乐指数 $r_i$。

第 $(n + 2)$ 到第 $2n$ 行，每行输入一对整数 $l, k$，代表 $k$ 是 $l$ 的直接上司。

## 输出格式

输出一行一个整数代表最大的快乐指数。

## 输入输出样例 #1

### 输入 #1

```
7
1
1
1
1
1
1
1
1 3
2 3
6 4
7 4
4 5
3 5

```

### 输出 #1

```
5

```

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1\leq n \leq 6 \times 10^3$，$-128 \leq r_i\leq 127$，$1 \leq l, k \leq n$，且给出的关系一定是一棵树。  
首先第一个问题其实就是建树，这里的人都是从1开始的序列，所以直接用一个数组储存信息就可以啦，对应人的编号直接作为索引访问数组中属于这个人的信息  
要储存的信息显然有，他的快乐指数，他的左儿子的索引（手下1）和右儿子的索引（手下2），还有一个就是我们要得到的dp值，这个dp值是指考虑以这个点为根节点的整棵树的人的最大快乐指数的和  
那么这个状态的初始当然是发现左右子树都不存在（索引都为初始值0）的时候，直接返还这个员工的快乐指数作为dp的值，对于非叶子节点，我们需要状态转移，状态转移方程如下  
```cpp
tree[root].sum=max(tree[tree[root].sub1].sum+tree[tree[root].sub2].sum,
tree[tree[tree[root].sub1].sub1].sum+tree[tree[tree[root].sub1].sub2].sum+
tree[tree[tree[root].sub2].sub1].sum+tree[tree[tree[root].sub2].sub2].sum+tree[root].index);
```
那么就有一个问题了，在计算根节点的时候，我们需要向下递归，而这个递归必须要是记忆化的递归，否则算法复杂度会极大提升  
因为我们在调用根节点的时候会调用其左子树的左儿子，而调用根节点同时也会调用左子树，而调用左子树的时候又会调用左子树的左儿子，显然左子树的左儿子被不必要地反复调用了  
而越下层的点被调用的次数越多，呈指数型增长，因此必须是记忆化的递归，其实也就是dp的一种，我们可以根据这个思路写出一个函数，这个函数不已return的方式返还结果（非记忆化递归），而是将对应结果记录于一个定义在全局的数组上面，这也是记忆化递归的惯用套路。  
我们只需要在状态转移之前先调用左右子树的函数，就可以得到左右子树的答案，而左右子树的儿子在得到左右子树的答案的时候已经被调用过了，所以可以直接使用。  
这是我独立完成的一道题目，代码如下  
```cpp
#include<iostream>
using namespace std;
#include<vector>
struct staff
{
	int sub1,sub2;
	int index;
	int sum;
};
vector<staff> tree;
void treedp(int root)
{
	if(root==0)
	{
		return;
	}
	if(tree[root].sub1==0&&tree[root].sub2==0)
	{
		tree[root].sum=tree[root].index;
		return;
	}
	else
	{
		if(tree[tree[root].sub1].sum==-1)
		{
			treedp(tree[root].sub1);
		}
		if(tree[tree[root].sub2].sum==-1)
		{
			treedp(tree[root].sub2);
		}
		tree[root].sum=max(tree[tree[root].sub1].sum+tree[tree[root].sub2].sum,
		tree[tree[tree[root].sub1].sub1].sum+tree[tree[tree[root].sub1].sub2].sum+
		tree[tree[tree[root].sub2].sub1].sum+tree[tree[tree[root].sub2].sub2].sum+tree[root].index);
		return;
	}
}
int main()
{
	int n,root;
	cin>>n;
	tree.resize(n+1);
	vector<int> find(n+1.0);
	tree[0].index=0;
	tree[0].sub1=0;
	tree[0].sub2=0;
	tree[0].sum=0;
	for(int i=1;i<=n;i++)
	{
		cin>>tree[i].index;
		tree[i].sub1=0;
		tree[i].sub2=0;
		tree[i].sum=-1;
	}
	for(int j=1;j<=n-1;j++)
	{
		int sub=0;
		int boss=0;
		cin>>sub>>boss;
		if(tree[boss].sub1)
		{
			tree[boss].sub2=sub;
		}
		else
		{
			tree[boss].sub1=sub;
		}
		find[sub]=1;
	}
	for(int i=1;i<=n;i++)
	{
		if(find[i]==0)
		{
			root=i;
			break;
		}
	}
	treedp(root);
	cout<<tree[root].sum;
	return 0;
}
```
这个代码在细节等方面已经处理得很好了，但是还是错了一个测试点，原因是题目说公司员工最终构成的结构是一棵树，没有说是二叉树，那么我们可以在节点结构体中多加一个数据，index来记录儿子的数量，原本的左右子树变量改成一个有儿子变量的索引组成的数组。  
代码更改后如下  
```cpp
#include<iostream>
using namespace std;
#include<vector>
struct staff
{
	int m;
	//vector<int> sub(1,0);
	vector<int> sub;
	int index;
	int sum;
};
vector<staff> tree;
void treedp(int root)
{
	if(root==0)
	{
		return;
	}
	if(tree[root].m==0)
	{
		tree[root].sum=tree[root].index;
		return;
	}
	else
	{
		int sum1=0;
		int sum2=0;
		for(int i=1;i<=tree[root].m;i++)
		{
			if(tree[tree[root].sub[i]].sum==-1)
			treedp(tree[root].sub[i]);
		}
		for(int i=1;i<=tree[root].m;i++)
		{
			sum1+=tree[tree[root].sub[i]].sum;
		}
		for(int i=1;i<=tree[root].m;i++)
		{
			for(int j=1;j<=tree[tree[root].sub[i]].m;j++)
			{
				sum2+=tree[tree[tree[root].sub[i]].sub[j]].sum;
			}
		}
		sum2+=tree[root].index;
		tree[root].sum=max(sum1,sum2);
		return;
	}
}
int main()
{
	int n,root;
	cin>>n;
	tree.resize(n+1);
	vector<int> find(n+1.0);
	tree[0].index=0;
	tree[0].m=0;
	tree[0].sum=0;
	for(int i=1;i<=n;i++)
	{
		cin>>tree[i].index;
		tree[i].m=0;
		tree[i].sum=-1;
		tree[i].sub.push_back(0);
	}
	for(int j=1;j<=n-1;j++)
	{
		int sub=0;
		int boss=0;
		cin>>sub>>boss;
		tree[boss].m++;
		tree[boss].sub.push_back(sub);
		find[sub]=1;
	}
	for(int i=1;i<=n;i++)
	{
		if(find[i]==0)
		{
			root=i;
			break;
		}
	}
	treedp(root);
	cout<<tree[root].sum;
	return 0;
}
```
