# 2026年1月28日 星期三  
显然，我心态炸了，写了一个小时的博客因为没有保存所以完全没了，现在在补写一份。  
这一份就写快一点了，不多废话，集训结束，因为生病最后测试爆零，努力补题  
先说两个小的知识点  
第一个，max函数普通版在iostream里面，只能两个变量，max(a,b),升级版的在algorithm里面，形式是max({a,b,c...});
第二个，cin>>后面的变量不能是类型不对的，不会强制转换，否则会读入失败，保留变量原先的数据。只有变量给变量赋值才会触发强制转换  

总共6道集训题，3道cf的div3题  

第一道  
石子合并，第一次写区间dp题目  
题目难度：绿题  

# P1880 [NOI1995] 石子合并

## 题目描述

在一个圆形操场的四周摆放 $N$ 堆石子，现要将石子有次序地合并成一堆，规定每次只能选相邻的 $2$ 堆合并成新的一堆，并将新的一堆的石子数，记为该次合并的得分。

试设计出一个算法,计算出将 $N$ 堆石子合并成 $1$ 堆的最小得分和最大得分。

## 输入格式

数据的第 $1$ 行是正整数 $N$，表示有 $N$ 堆石子。

第 $2$ 行有 $N$ 个整数，第 $i$ 个整数 $a_i$ 表示第 $i$ 堆石子的个数。

## 输出格式

输出共 $2$ 行，第 $1$ 行为最小得分，第 $2$ 行为最大得分。

## 输入输出样例 #1

### 输入 #1

```
4
4 5 9 4
```

### 输出 #1

```
43
54
```

## 说明/提示

$1\leq N\leq 100$，$0\leq a_i\leq 20$。

这个区间dp题的思路是枚举一个区间内所有最后合并的分割点，然后将左右两边的dp值加起来，再加上这个区间的数据和，记得dp值是合并的值，单个数字的dp值是零  
这个算法的时间复杂度是n的三次方，有更复杂的方法可以优化，后面我再学，此题和普通石子合并的区别在于它的石子是围成一圈的，只需要我们把石子复制一遍加进去，枚举区间为4的，找出最大的即可  
因为石子合并最后两堆合并的时候相当于一排，所以可以看作是最后分割点左边一部分右边一部分。因为第一次写区间dp，所以当然是看了题解学习的    
代码如下  
```cpp
#include<iostream>
using namespace std;
#include<vector>
int main()
{
	int n,num;
	cin>>n;
	vector<int> arr,sum(2*n+1,0);
	arr.push_back(1);
	for(int i=1;i<=n;i++)
	{
		cin>>num;
		arr.push_back(num);
	}
	for(int i=1;i<=n;i++)
	{
		arr.push_back(arr[i]);
	}
	for(int i=1;i<=2*n;i++)
	{
		sum[i]=sum[i-1]+arr[i];
	}
	vector<vector<int> >dp1(2*n+1,vector<int>(2*n+1,0));
	vector<vector<int> >dp2(2*n+1,vector<int>(2*n+1,1e9));
	for(int i=1;i<=2*n;i++)
	{
		dp2[i][i]=0;
	}
	for(int i=2;i<=n;i++)
	{
		for(int j=1;j<=2*n+1-i;j++)
		{
			for(int k=j;k<=j+i-2;k++)
			{
				dp1[j][j+i-1]=max(dp1[j][k]+dp1[k+1][j+i-1]+sum[k]-sum[j-1]+sum[j+i-1]-sum[k],dp1[j][j+i-1]);
				dp2[j][j+i-1]=min(dp2[j][k]+dp2[k+1][j+i-1]+sum[k]-sum[j-1]+sum[j+i-1]-sum[k],dp2[j][j+i-1]);
			}
		}
	}
	int best=0,worst=1e9;
	for(int i=1;i<=n;i++)
	{
		best=max(best,dp1[i][i+n-1]);
		worst=min(worst,dp2[i][i+n-1]);
	}
	cout<<worst<<endl<<best<<endl;
	return 0;
}
```

下一题  
最长公共子序列  
题目如下，难度：蓝题！
