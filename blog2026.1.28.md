# 2026年1月28日 星期三  
显然，我心态炸了，写了一个小时的博客因为没有保存所以完全没了，现在在补写一份。  
这一份就写快一点了，不多废话，集训结束，因为生病最后测试爆零，努力补题  
先说两个小的知识点  
第一个，max函数普通版在iostream里面，只能两个变量，max(a,b),升级版的在algorithm里面，形式是max({a,b,c...});
第二个，cin>>后面的变量不能是类型不对的，不会强制转换，否则会读入失败，保留变量原先的数据。只有变量给变量赋值才会触发强制转换  

总共6道集训题（甚至有蓝题），3道cf的div3题  

第一道  
石子合并，第一次写区间dp题目  
题目难度：绿题  

# P1880 [NOI1995] 石子合并

## 题目描述

在一个圆形操场的四周摆放 $N$ 堆石子，现要将石子有次序地合并成一堆，规定每次只能选相邻的 $2$ 堆合并成新的一堆，并将新的一堆的石子数，记为该次合并的得分。

试设计出一个算法,计算出将 $N$ 堆石子合并成 $1$ 堆的最小得分和最大得分。

## 输入格式

数据的第 $1$ 行是正整数 $N$，表示有 $N$ 堆石子。

第 $2$ 行有 $N$ 个整数，第 $i$ 个整数 $a_i$ 表示第 $i$ 堆石子的个数。

## 输出格式

输出共 $2$ 行，第 $1$ 行为最小得分，第 $2$ 行为最大得分。

## 输入输出样例 #1

### 输入 #1

```
4
4 5 9 4
```

### 输出 #1

```
43
54
```

## 说明/提示

$1\leq N\leq 100$，$0\leq a_i\leq 20$。

这个区间dp题的思路是枚举一个区间内所有最后合并的分割点，然后将左右两边的dp值加起来，再加上这个区间的数据和，记得dp值是合并的值，单个数字的dp值是零  
这个算法的时间复杂度是n的三次方，有更复杂的方法可以优化，后面我再学，此题和普通石子合并的区别在于它的石子是围成一圈的，只需要我们把石子复制一遍加进去，枚举区间为4的，找出最大的即可  
因为石子合并最后两堆合并的时候相当于一排，所以可以看作是最后分割点左边一部分右边一部分。因为第一次写区间dp，所以当然是看了题解学习的    
代码如下  
```cpp
#include<iostream>
using namespace std;
#include<vector>
int main()
{
	int n,num;
	cin>>n;
	vector<int> arr,sum(2*n+1,0);
	arr.push_back(1);
	for(int i=1;i<=n;i++)
	{
		cin>>num;
		arr.push_back(num);
	}
	for(int i=1;i<=n;i++)
	{
		arr.push_back(arr[i]);
	}
	for(int i=1;i<=2*n;i++)
	{
		sum[i]=sum[i-1]+arr[i];
	}
	vector<vector<int> >dp1(2*n+1,vector<int>(2*n+1,0));
	vector<vector<int> >dp2(2*n+1,vector<int>(2*n+1,1e9));
	for(int i=1;i<=2*n;i++)
	{
		dp2[i][i]=0;
	}
	for(int i=2;i<=n;i++)
	{
		for(int j=1;j<=2*n+1-i;j++)
		{
			for(int k=j;k<=j+i-2;k++)
			{
				dp1[j][j+i-1]=max(dp1[j][k]+dp1[k+1][j+i-1]+sum[k]-sum[j-1]+sum[j+i-1]-sum[k],dp1[j][j+i-1]);
				dp2[j][j+i-1]=min(dp2[j][k]+dp2[k+1][j+i-1]+sum[k]-sum[j-1]+sum[j+i-1]-sum[k],dp2[j][j+i-1]);
			}
		}
	}
	int best=0,worst=1e9;
	for(int i=1;i<=n;i++)
	{
		best=max(best,dp1[i][i+n-1]);
		worst=min(worst,dp2[i][i+n-1]);
	}
	cout<<worst<<endl<<best<<endl;
	return 0;
}
```

下一题  
最长公共子序列  
题目如下，难度：蓝题！
# P2516 [HAOI2010] 最长公共子序列

## 题目描述

字符序列的子序列是指从给定字符序列中随意地（不一定连续）去掉若干个字符（可能一个也不去掉）后所形成的字符序列。令给定的字符序列 $X=\{x_0,x_1,\cdots ,x_{m-1}\}$，序列 $Y=\{y_0,y_1,\cdots ,y_{k-1}\}$ 是 $X$ 的子序列，当且仅当存在 $X$ 的一个严格递增下标序列 $\{i_0,i_1,\cdots,i_{k-1}\}$ ，使得对所有的 $j=0,1,\cdots,k-1$ ，有 $x_{i_j}=y_j$ 。例如，$X=\verb!"ABCBDAB"!$ ，$Y=\verb!"BCDB"!$ 是 $X$ 的一个子序列。对给定的两个字符序列，求出他们最长的公共子序列长度，以及最长公共子序列个数。其中，两个子序列 $i$ 和 $j$ 不同，当且仅当长度不同或子序列中 $\exist k, i_k \neq j_k$。

## 输入格式

第一行为第一个字符序列，都是大写字母组成，以 `.` 结束，大写字母个数不超过 $5000$。

第二行为第二个字符序列，都是大写字母组成，以 `.` 结束，大写字母个数不超过 $5000$。

## 输出格式

第一行输出上述两个最长公共子序列的长度。

第二行输出所有可能出现的最长公共子序列个数，答案可能很大，只要将答案对 $10^{8}$ 求余即可。

## 输入输出样例 #1

### 输入 #1

```
ABCBDAB.
BACBBD.
```

### 输出 #1

```
4
7
```
最长公共子序列的长度是基本的dp题目，但是这一题加上了最长公共子序列的条数  
先说长度，
dp[n][m]=dp[n-1][m-1]+1(a[n]=b[m])  
dp[n][m]=max(dp[n-1][m],dp[n][m-1])(a[n]!=b[m])  
很好理解，而条数整体也分两种情况  
a[n]=b[m]时  
如果dp[n][m-1]的长度等于dp[n][m]，那么这部分的条数一定可以加上去，因为dp[n][m]的长度等于dp[n-1][m-1]+1,即这部分是用到了a[n]而没有用到b[m]的，同理，dp[n-1][m]也是相同处理，最后再加上dp[n-1][m-1]的条数，这部分是同时用到了a[n]和b[m].  
a[n]!=b[m]时  
此时可以分成三种情况，第一种是dp[n-1][m]和dp[n][m-1]长度不一样，那么因为a[n]!=b[m]所以不可能a[n],b[m]同时用到，而dp[n][m]就完全继承了那两个中长的那一个，第二种情况是dp[n-1][m]长度等于dp[n][m=1]同时大于dp[n-1][m-1]  
此时可以知道，dp[n][m]肯定用到了a[n]或者b[m]我们直接将dp[n][m-1]和dp[n-1][m]相加，就可以得到，最后一种是dp[n-1][m]长度等于dp[n][m=1]同时等于于dp[n-1][m-1]，那么dp[n][m]可能用到了a[n],也可能用到了b[m]，也可能都没用到  
此时dp[n][m-1]表示了其中用到了a[n]和都没用到的那部分，我们用dp[n][m-1]+dp[n-1][m]，但是由于多加了一次a[n]和b[m]都没用的，所以最后再-dp[n-1][m-1],切记这道题要考虑的那部分要满足那部分的长度等于dp[n][m]长度，因为这样才会成为dp[n][m]的最长公共子序列。  
如果短了，就不是最长  
下面是根据这个思路的代码  
```cpp
#include<iostream>
using namespace std;
#include<string>
struct ll
{
	int len;
	int num;
};
int main()
{
	string A,B;
	cin>>A;
	cin>>B;
	int n=A.length()-1;
	int m=B.length()-1;
	ll arr[n+1][m+1];
	for(int i=0;i<=n;i++)
	{
		arr[i][0].len=0;
		arr[i][0].num=1;
	}
	for(int i=0;i<=m;i++)
	{
		arr[0][i].len=0;
		arr[0][i].num=1;
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			arr[i][j].num=0;
			if(A[i-1]==B[j-1])
			{
				arr[i][j].len=arr[i-1][j-1].len+1;
				//if(arr[i-1][j].len==arr[i][j].len&&arr[i][j-1].len==arr[i][j].len)
				//{
				//	arr[i][j].num=arr[i-1][j-1].num;
				//}
				if(arr[i-1][j].len==arr[i][j].len)
				{
					arr[i][j].num=(arr[i-1][j].num+arr[i][j].num)%100000000;
				}
				if(arr[i][j-1].len==arr[i][j].len)
				{
					arr[i][j].num=(arr[i][j-1].num+arr[i][j].num)%100000000;
				}
				arr[i][j].num=(arr[i-1][j-1].num+arr[i][j].num)%100000000;
			}
			else
			{
				if(arr[i-1][j].len>arr[i][j-1].len)
				{
					arr[i][j].len=arr[i-1][j].len;
					arr[i][j].num=arr[i-1][j].num;
					continue;
				}			
				if(arr[i-1][j].len<arr[i][j-1].len)
				{
					arr[i][j].len=arr[i][j-1].len;
					arr[i][j].num=arr[i][j-1].num;
					continue;
				}
				if(arr[i-1][j].len==arr[i-1][j-1].len)
				{
					arr[i][j].len=arr[i][j-1].len;
					arr[i][j].num=(arr[i][j-1].num+arr[i-1][j].num-arr[i-1][j-1].num)%100000000;
				}
				else
				{
					arr[i][j].len=arr[i][j-1].len;
					arr[i][j].num=(arr[i][j-1].num+arr[i-1][j].num)%100000000;
				}
			}
		}
	}
	cout<<arr[n][m].len<<endl<<arr[n][m].num;
	return 0;
}
```
但是提交上去会发现，很好，MLE了  
这是因为两个5000×5000的int数组（我用的是结构体数组，一个结构体数组，但是一个结构体有两个int，因为必须记录长度和个数）  
占用的内存约为2×4（一个int四个字节）×5000×5000约等于200MB，而题目只给了125MB  
此时看到dp的值只与上一列以及这一列已经推导出来的值有关，所以想到了滚动数组，依照滚动数组的理解修改了一下  
```cpp
#include<iostream>
using namespace std;
#include<string>
struct ll
{
	int len;
	int num;
};
int main()
{
	string A,B;
	cin>>A;
	cin>>B;
	int n=A.length()-1;
	int m=B.length()-1;
	ll arr[2][m+1];
	for(int i=0;i<=1;i++)
	{
		arr[i][0].len=0;
		arr[i][0].num=1;
	}
	for(int i=0;i<=m;i++)
	{
		arr[0][i].len=0;
		arr[0][i].num=1;
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			arr[1][j].num=0;
            arr[1][j].len=0;
			if(A[i-1]==B[j-1])
			{
				arr[1][j].len=arr[0][j-1].len+1;
				//if(arr[i-1][j].len==arr[i][j].len&&arr[i][j-1].len==arr[i][j].len)
				//{
				//	arr[i][j].num=arr[i-1][j-1].num;
				//}
				if(arr[0][j].len==arr[1][j].len)
				{
					arr[1][j].num=(arr[0][j].num+arr[1][j].num)%100000000;
				}
				if(arr[1][j-1].len==arr[1][j].len)
				{
					arr[1][j].num=(arr[1][j-1].num+arr[1][j].num)%100000000;
				}
				arr[1][j].num=(arr[0][j-1].num+arr[1][j].num)%100000000;
			}
			else
			{
				if(arr[0][j].len>arr[1][j-1].len)
				{
					arr[1][j].len=arr[0][j].len;
					arr[1][j].num=arr[0][j].num;
					continue;
				}			
				if(arr[0][j].len<arr[1][j-1].len)
				{
					arr[1][j].len=arr[1][j-1].len;
					arr[1][j].num=arr[1][j-1].num;
                    
					continue;
				}
				if(arr[0][j].len==arr[0][j-1].len)
				{
					arr[1][j].len=arr[1][j-1].len;
					arr[1][j].num=(arr[1][j-1].num+arr[0][j].num-arr[0][j-1].num)%100000000;
				}
				else
				{
					arr[1][j].len=arr[1][j-1].len;
					arr[1][j].num=(arr[1][j-1].num+arr[0][j].num)%100000000;
				}
			}
		}
        for(int j=1;j<=m;j++)
        {
            arr[0][j].len=arr[1][j].len;
            arr[0][j].num=arr[1][j].num;
        }
	}
	cout<<arr[1][m].len<<endl<<arr[1][m].num;
	return 0;
}
```
完美解决了MLE的问题，这道题全程自己做，第一次解出蓝题，非常高兴，进步肉眼可见  
而且解决MLE的思路特别有价值  



