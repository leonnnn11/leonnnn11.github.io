# 2026年1月28日 星期三  
显然，我心态炸了，写了一个小时的博客因为没有保存所以完全没了，现在在补写一份。  
这一份就写快一点了，不多废话，集训结束，因为生病最后测试爆零，努力补题  
先说两个小的知识点  
第一个，max函数普通版在iostream里面，只能两个变量，max(a,b),升级版的在algorithm里面，形式是max({a,b,c...});
第二个，cin>>后面的变量不能是类型不对的，不会强制转换，否则会读入失败，保留变量原先的数据。只有变量给变量赋值才会触发强制转换  

总共6道集训题（甚至有蓝题），3道cf的div3题  

第一道  
石子合并，第一次写区间dp题目  
题目难度：绿题  

# P1880 [NOI1995] 石子合并

## 题目描述

在一个圆形操场的四周摆放 $N$ 堆石子，现要将石子有次序地合并成一堆，规定每次只能选相邻的 $2$ 堆合并成新的一堆，并将新的一堆的石子数，记为该次合并的得分。

试设计出一个算法,计算出将 $N$ 堆石子合并成 $1$ 堆的最小得分和最大得分。

## 输入格式

数据的第 $1$ 行是正整数 $N$，表示有 $N$ 堆石子。

第 $2$ 行有 $N$ 个整数，第 $i$ 个整数 $a_i$ 表示第 $i$ 堆石子的个数。

## 输出格式

输出共 $2$ 行，第 $1$ 行为最小得分，第 $2$ 行为最大得分。

## 输入输出样例 #1

### 输入 #1

```
4
4 5 9 4
```

### 输出 #1

```
43
54
```

## 说明/提示

$1\leq N\leq 100$，$0\leq a_i\leq 20$。

这个区间dp题的思路是枚举一个区间内所有最后合并的分割点，然后将左右两边的dp值加起来，再加上这个区间的数据和，记得dp值是合并的值，单个数字的dp值是零  
这个算法的时间复杂度是n的三次方，有更复杂的方法可以优化，后面我再学，此题和普通石子合并的区别在于它的石子是围成一圈的，只需要我们把石子复制一遍加进去，枚举区间为4的，找出最大的即可  
因为石子合并最后两堆合并的时候相当于一排，所以可以看作是最后分割点左边一部分右边一部分。因为第一次写区间dp，所以当然是看了题解学习的    
代码如下  
```cpp
#include<iostream>
using namespace std;
#include<vector>
int main()
{
	int n,num;
	cin>>n;
	vector<int> arr,sum(2*n+1,0);
	arr.push_back(1);
	for(int i=1;i<=n;i++)
	{
		cin>>num;
		arr.push_back(num);
	}
	for(int i=1;i<=n;i++)
	{
		arr.push_back(arr[i]);
	}
	for(int i=1;i<=2*n;i++)
	{
		sum[i]=sum[i-1]+arr[i];
	}
	vector<vector<int> >dp1(2*n+1,vector<int>(2*n+1,0));
	vector<vector<int> >dp2(2*n+1,vector<int>(2*n+1,1e9));
	for(int i=1;i<=2*n;i++)
	{
		dp2[i][i]=0;
	}
	for(int i=2;i<=n;i++)
	{
		for(int j=1;j<=2*n+1-i;j++)
		{
			for(int k=j;k<=j+i-2;k++)
			{
				dp1[j][j+i-1]=max(dp1[j][k]+dp1[k+1][j+i-1]+sum[k]-sum[j-1]+sum[j+i-1]-sum[k],dp1[j][j+i-1]);
				dp2[j][j+i-1]=min(dp2[j][k]+dp2[k+1][j+i-1]+sum[k]-sum[j-1]+sum[j+i-1]-sum[k],dp2[j][j+i-1]);
			}
		}
	}
	int best=0,worst=1e9;
	for(int i=1;i<=n;i++)
	{
		best=max(best,dp1[i][i+n-1]);
		worst=min(worst,dp2[i][i+n-1]);
	}
	cout<<worst<<endl<<best<<endl;
	return 0;
}
```

下一题  
最长公共子序列  
题目如下，难度：蓝题！
# P2516 [HAOI2010] 最长公共子序列

## 题目描述

字符序列的子序列是指从给定字符序列中随意地（不一定连续）去掉若干个字符（可能一个也不去掉）后所形成的字符序列。令给定的字符序列 $X=\{x_0,x_1,\cdots ,x_{m-1}\}$，序列 $Y=\{y_0,y_1,\cdots ,y_{k-1}\}$ 是 $X$ 的子序列，当且仅当存在 $X$ 的一个严格递增下标序列 $\{i_0,i_1,\cdots,i_{k-1}\}$ ，使得对所有的 $j=0,1,\cdots,k-1$ ，有 $x_{i_j}=y_j$ 。例如，$X=\verb!"ABCBDAB"!$ ，$Y=\verb!"BCDB"!$ 是 $X$ 的一个子序列。对给定的两个字符序列，求出他们最长的公共子序列长度，以及最长公共子序列个数。其中，两个子序列 $i$ 和 $j$ 不同，当且仅当长度不同或子序列中 $\exist k, i_k \neq j_k$。

## 输入格式

第一行为第一个字符序列，都是大写字母组成，以 `.` 结束，大写字母个数不超过 $5000$。

第二行为第二个字符序列，都是大写字母组成，以 `.` 结束，大写字母个数不超过 $5000$。

## 输出格式

第一行输出上述两个最长公共子序列的长度。

第二行输出所有可能出现的最长公共子序列个数，答案可能很大，只要将答案对 $10^{8}$ 求余即可。

## 输入输出样例 #1

### 输入 #1

```
ABCBDAB.
BACBBD.
```

### 输出 #1

```
4
7
```
最长公共子序列的长度是基本的dp题目，但是这一题加上了最长公共子序列的条数  
先说长度，
dp[n][m]=dp[n-1][m-1]+1(a[n]=b[m])  
dp[n][m]=max(dp[n-1][m],dp[n][m-1])(a[n]!=b[m])  
很好理解，而条数整体也分两种情况  
a[n]=b[m]时  
如果dp[n][m-1]的长度等于dp[n][m]，那么这部分的条数一定可以加上去，因为dp[n][m]的长度等于dp[n-1][m-1]+1,即这部分是用到了a[n]而没有用到b[m]的，同理，dp[n-1][m]也是相同处理，最后再加上dp[n-1][m-1]的条数，这部分是同时用到了a[n]和b[m].  
a[n]!=b[m]时  
此时可以分成三种情况，第一种是dp[n-1][m]和dp[n][m-1]长度不一样，那么因为a[n]!=b[m]所以不可能a[n],b[m]同时用到，而dp[n][m]就完全继承了那两个中长的那一个，第二种情况是dp[n-1][m]长度等于dp[n][m=1]同时大于dp[n-1][m-1]  
此时可以知道，dp[n][m]肯定用到了a[n]或者b[m]我们直接将dp[n][m-1]和dp[n-1][m]相加，就可以得到，最后一种是dp[n-1][m]长度等于dp[n][m=1]同时等于于dp[n-1][m-1]，那么dp[n][m]可能用到了a[n],也可能用到了b[m]，也可能都没用到  
此时dp[n][m-1]表示了其中用到了a[n]和都没用到的那部分，我们用dp[n][m-1]+dp[n-1][m]，但是由于多加了一次a[n]和b[m]都没用的，所以最后再-dp[n-1][m-1],切记这道题要考虑的那部分要满足那部分的长度等于dp[n][m]长度，因为这样才会成为dp[n][m]的最长公共子序列。  
如果短了，就不是最长  
下面是根据这个思路的代码  
```cpp
#include<iostream>
using namespace std;
#include<string>
struct ll
{
	int len;
	int num;
};
int main()
{
	string A,B;
	cin>>A;
	cin>>B;
	int n=A.length()-1;
	int m=B.length()-1;
	ll arr[n+1][m+1];
	for(int i=0;i<=n;i++)
	{
		arr[i][0].len=0;
		arr[i][0].num=1;
	}
	for(int i=0;i<=m;i++)
	{
		arr[0][i].len=0;
		arr[0][i].num=1;
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			arr[i][j].num=0;
			if(A[i-1]==B[j-1])
			{
				arr[i][j].len=arr[i-1][j-1].len+1;
				//if(arr[i-1][j].len==arr[i][j].len&&arr[i][j-1].len==arr[i][j].len)
				//{
				//	arr[i][j].num=arr[i-1][j-1].num;
				//}
				if(arr[i-1][j].len==arr[i][j].len)
				{
					arr[i][j].num=(arr[i-1][j].num+arr[i][j].num)%100000000;
				}
				if(arr[i][j-1].len==arr[i][j].len)
				{
					arr[i][j].num=(arr[i][j-1].num+arr[i][j].num)%100000000;
				}
				arr[i][j].num=(arr[i-1][j-1].num+arr[i][j].num)%100000000;
			}
			else
			{
				if(arr[i-1][j].len>arr[i][j-1].len)
				{
					arr[i][j].len=arr[i-1][j].len;
					arr[i][j].num=arr[i-1][j].num;
					continue;
				}			
				if(arr[i-1][j].len<arr[i][j-1].len)
				{
					arr[i][j].len=arr[i][j-1].len;
					arr[i][j].num=arr[i][j-1].num;
					continue;
				}
				if(arr[i-1][j].len==arr[i-1][j-1].len)
				{
					arr[i][j].len=arr[i][j-1].len;
					arr[i][j].num=(arr[i][j-1].num+arr[i-1][j].num-arr[i-1][j-1].num)%100000000;
				}
				else
				{
					arr[i][j].len=arr[i][j-1].len;
					arr[i][j].num=(arr[i][j-1].num+arr[i-1][j].num)%100000000;
				}
			}
		}
	}
	cout<<arr[n][m].len<<endl<<arr[n][m].num;
	return 0;
}
```
但是提交上去会发现，很好，MLE了  
这是因为两个5000×5000的int数组（我用的是结构体数组，一个结构体数组，但是一个结构体有两个int，因为必须记录长度和个数）  
占用的内存约为2×4（一个int四个字节）×5000×5000约等于200MB，而题目只给了125MB  
此时看到dp的值只与上一列以及这一列已经推导出来的值有关，所以想到了滚动数组，依照滚动数组的理解修改了一下  
```cpp
#include<iostream>
using namespace std;
#include<string>
struct ll
{
	int len;
	int num;
};
int main()
{
	string A,B;
	cin>>A;
	cin>>B;
	int n=A.length()-1;
	int m=B.length()-1;
	ll arr[2][m+1];
	for(int i=0;i<=1;i++)
	{
		arr[i][0].len=0;
		arr[i][0].num=1;
	}
	for(int i=0;i<=m;i++)
	{
		arr[0][i].len=0;
		arr[0][i].num=1;
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			arr[1][j].num=0;
            arr[1][j].len=0;
			if(A[i-1]==B[j-1])
			{
				arr[1][j].len=arr[0][j-1].len+1;
				//if(arr[i-1][j].len==arr[i][j].len&&arr[i][j-1].len==arr[i][j].len)
				//{
				//	arr[i][j].num=arr[i-1][j-1].num;
				//}
				if(arr[0][j].len==arr[1][j].len)
				{
					arr[1][j].num=(arr[0][j].num+arr[1][j].num)%100000000;
				}
				if(arr[1][j-1].len==arr[1][j].len)
				{
					arr[1][j].num=(arr[1][j-1].num+arr[1][j].num)%100000000;
				}
				arr[1][j].num=(arr[0][j-1].num+arr[1][j].num)%100000000;
			}
			else
			{
				if(arr[0][j].len>arr[1][j-1].len)
				{
					arr[1][j].len=arr[0][j].len;
					arr[1][j].num=arr[0][j].num;
					continue;
				}			
				if(arr[0][j].len<arr[1][j-1].len)
				{
					arr[1][j].len=arr[1][j-1].len;
					arr[1][j].num=arr[1][j-1].num;
                    
					continue;
				}
				if(arr[0][j].len==arr[0][j-1].len)
				{
					arr[1][j].len=arr[1][j-1].len;
					arr[1][j].num=(arr[1][j-1].num+arr[0][j].num-arr[0][j-1].num)%100000000;
				}
				else
				{
					arr[1][j].len=arr[1][j-1].len;
					arr[1][j].num=(arr[1][j-1].num+arr[0][j].num)%100000000;
				}
			}
		}
        for(int j=1;j<=m;j++)
        {
            arr[0][j].len=arr[1][j].len;
            arr[0][j].num=arr[1][j].num;
        }
	}
	cout<<arr[1][m].len<<endl<<arr[1][m].num;
	return 0;
}
```
完美解决了MLE的问题，这道题全程自己做，第一次解出蓝题，非常高兴，进步肉眼可见  
而且解决MLE的思路特别有价值  
下一题  
导弹拦截  
其实就是最长上升/下降子序列  
题目如下，难度：绿题
# P1020 [NOIP 1999 提高组] 导弹拦截

## 题目描述

某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。

   
输入导弹依次飞来的高度，计算这套系统最多能拦截多少导弹，如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。

## 输入格式

一行，若干个整数，中间由空格隔开。

## 输出格式

两行，每行一个整数，第一个数字表示这套系统最多能拦截多少导弹，第二个数字表示如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。

## 输入输出样例 #1

### 输入 #1

```
389 207 155 300 299 170 158 65
```

### 输出 #1

```
6
2

```

## 说明/提示

对于前 $50\%$ 数据，满足导弹的个数不超过 $10^4$ 个。该部分数据总分共 $100$ 分。可使用 $\mathcal O(n^2)$ 做法通过。  
对于后 $50\%$ 的数据，满足导弹的个数不超过 $10^5$ 个。该部分数据总分也为 $100$ 分。请使用 $\mathcal O(n\log n)$ 做法通过。

对于全部数据，满足导弹的高度为正整数，且不超过 $5\times 10^4$。


此外本题开启 spj，每点两问，按问给分。

NOIP1999 提高组 第一题

---

$\text{upd 2022.8.24}$：新增加一组 Hack 数据。

显然一套系统最多拦截的导弹数量就是最长不上升子序列（相同也可以，不一定要下降），而需要多少个不下降序列才能完全覆盖，这个东西的数量恰好是最长上升子序列的长度，因为我们可以这样，将新来的数据接到已有序列的尾部（选择最刚好比这个数大的那个尾部），如果  
所有尾部都不行，就新开一个数组，我们最后取每个数组的最后一个数字，因为新来的数据都是用贪心插入法（左边的数组数字一定比它小，不然就会插入到左边取），取完组成了一个上升序列，设长度为n，则最长上升子序列的长度至少是n，而一个数组的两个数字不可能同时出现在  
一个上升子序列中，因为一个数组上面的数字更大（或者相等），但是来得更早，所以长度最多也只有n。  
终于证明完了复杂的数学问题，下面就要说一下最长上升子序列的n平方做法和nlogn做法了，n平方做法是用一个数组记录以每个数字结尾的最长上升子序列的长度，新来的数字的值的计算就是遍历前面的，选出比他小的数字中长度最长的+1就是以新数字结尾的最长上升子序列。  
而nlogn做法就是记录每个长度的上升子序列的末尾的最小值，然后新来数字就找到刚好比新数字大的那个替换掉，如果比所有都大就扩大数组，其中查找用二分查找，所以复杂度是nlogn，我专门为这道题学了二分查找
这里复习一次upper_bound和lower_bound函数,前者是输入arr.begin(),arr.end(),m找到第一个完全大于m的数字



